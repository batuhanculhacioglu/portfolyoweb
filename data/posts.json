{
  "posts": [
    {
      "id": 1,
      "title": "STM32 ile RTOS Kullanımı",
      "summary": "FreeRTOS kullanarak STM32 mikrodenetleyicilerde çoklu görev yönetimi nasıl yapılır?",
      "content": "<h1>STM32 ve FreeRTOS</h1><p>Bu yazıda STM32F4 serisi mikrodenetleyicilerde FreeRTOS kullanımını inceleyeceğiz.</p><h2>Neden RTOS?</h2><p>Gömülü sistemlerde gerçek zamanlı işletim sistemi kullanmak, özellikle karmaşık projelerde büyük avantajlar sağlar:</p><ul><li><strong>Çoklu görev yönetimi</strong>: Birden fazla görevi eş zamanlı yönetebilme</li><li><strong>Zaman kritik uygulamalar</strong>: Deterministik davranış</li><li><strong>Kaynak yönetimi</strong>: Bellek ve CPU kullanımının optimize edilmesi</li></ul><h2>Kurulum Adımları</h2><ol><li>STM32CubeIDE'yi açın</li><li>Yeni proje oluşturun</li><li>Middleware sekmesinden FreeRTOS'u aktif edin</li><li>Task'ları ve önceliklerini ayarlayın</li></ol><h2>Örnek Kod</h2><pre><code class=\"language-c\">// LED yanıp sönme görevi\nvoid StartLEDTask(void const * argument)\n{\n    for(;;)\n    {\n        HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);\n        osDelay(1000);\n    }\n}\n\n// UART üzerinden veri gönderme görevi\nvoid StartUARTTask(void const * argument)\n{\n    char msg[] = \"Hello from FreeRTOS\\r\\n\";\n    for(;;)\n    {\n        HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), 100);\n        osDelay(2000);\n    }\n}</code></pre><h2>Dikkat Edilmesi Gerekenler</h2><ul><li>Stack boyutlarını doğru ayarlayın</li><li>Task önceliklerini mantıklı belirleyin</li><li>Kritik bölgelerde interrupt'ları devre dışı bırakın</li></ul><p>Daha fazla bilgi için <a href=\"https://www.freertos.org/Documentation/RTOS_book.html\" target=\"_blank\">FreeRTOS dokümantasyonunu</a> inceleyebilirsiniz.</p>",
      "tags": [
        "STM32",
        "RTOS",
        "FreeRTOS",
        "C",
        "Embedded"
      ],
      "date": "2025-01-15T10:30:00Z",
      "views": 167,
      "updatedDate": "2025-05-27T20:18:27.769Z"
    },
    {
      "id": 2,
      "title": "ESP32 ile IoT Projesi",
      "summary": "ESP32 kullanarak bulut tabanlı sıcaklık ve nem takip sistemi geliştirme",
      "content": "<h1>ESP32 IoT Sensör Projesi</h1><p>ESP32'nin WiFi özelliklerini kullanarak DHT22 sensöründen okunan verileri MQTT protokolü ile buluta gönderme projesi.</p><h2>Gerekli Malzemeler</h2><ul><li>ESP32 DevKit</li><li>DHT22 Sıcaklık ve Nem Sensörü</li><li>10K Pull-up Direnci</li><li>Jumper Kablolar</li></ul><h2>Bağlantı Şeması</h2><pre><code>ESP32    DHT22\n-----------------\n3.3V  -> VCC\nGND   -> GND\nGPIO4 -> DATA</code></pre><h2>Arduino Kodu</h2><pre><code class=\"language-cpp\">#include &lt;WiFi.h&gt;\n#include &lt;PubSubClient.h&gt;\n#include &lt;DHT.h&gt;\n\n#define DHTPIN 4\n#define DHTTYPE DHT22\n\nconst char* ssid = \"WiFi_SSID\";\nconst char* password = \"WiFi_PASSWORD\";\nconst char* mqtt_server = \"broker.mqtt.com\";\n\nDHT dht(DHTPIN, DHTTYPE);\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nvoid setup() {\n    Serial.begin(115200);\n    dht.begin();\n    setup_wifi();\n    client.setServer(mqtt_server, 1883);\n}\n\nvoid loop() {\n    if (!client.connected()) {\n        reconnect();\n    }\n    client.loop();\n    \n    float h = dht.readHumidity();\n    float t = dht.readTemperature();\n    \n    if (!isnan(h) && !isnan(t)) {\n        String payload = \"{\\\"temperature\\\":\" + String(t) + \",\\\"humidity\\\":\" + String(h) + \"}\";\n        client.publish(\"esp32/sensor\", payload.c_str());\n    }\n    \n    delay(5000);\n}</code></pre><h2>MQTT Broker Kurulumu</h2><p>Proje için Mosquitto MQTT broker kullanabilirsiniz. Alternatif olarak CloudMQTT gibi bulut servisleri de tercih edilebilir.</p><h2>Veri Görselleştirme</h2><p>Toplanan veriler Node-RED veya Grafana gibi araçlarla görselleştirilebilir.</p><blockquote><p><strong>İpucu:</strong> MQTT topic'lerini mantıklı bir şekilde organize etmeyi unutmayın. Örneğin: <code>ev/salon/sicaklik</code> veya <code>ev/salon/nem</code></p></blockquote>",
      "tags": [
        "ESP32",
        "IoT",
        "MQTT",
        "DHT22",
        "Arduino"
      ],
      "date": "2025-01-10T14:20:00Z",
      "views": 239,
      "updatedDate": "2025-05-23T21:20:36.121Z"
    },
    {
      "id": 3,
      "title": "Embedded Linux ile GPIO Kontrolü",
      "summary": "Raspberry Pi üzerinde C dilinde GPIO pin kontrolü ve kesme yönetimi",
      "content": "<h1>Linux GPIO Programlama</h1><p>Embedded Linux sistemlerde GPIO kontrolü için sysfs ve libgpiod kullanımını inceleyeceğiz.</p><h2>GPIO Nedir?</h2><p>GPIO (General Purpose Input/Output), mikrodenetleyici ve tek kartlı bilgisayarlarda bulunan çok amaçlı giriş/çıkış pinleridir. Bu pinler dijital sinyaller göndermek ve almak için kullanılır.</p><h2>Raspberry Pi GPIO Pin Yapısı</h2><p>Raspberry Pi'de 40 pinlik GPIO başlığı bulunur. Bu pinlerin bazıları güç pini, bazıları ise programlanabilir GPIO pinleridir.</p><h2>Sysfs ile GPIO Kontrolü</h2><p>Linux'ta GPIO pinleri <code>/sys/class/gpio/</code> dizini altından kontrol edilebilir:</p><pre><code class=\"language-bash\"># GPIO 18 pinini aktif et\necho 18 > /sys/class/gpio/export\n\n# Pin yönünü çıkış olarak ayarla\necho out > /sys/class/gpio/gpio18/direction\n\n# Pine lojik 1 (3.3V) gönder\necho 1 > /sys/class/gpio/gpio18/value\n\n# Pine lojik 0 (0V) gönder\necho 0 > /sys/class/gpio/gpio18/value</code></pre><h2>C Programlama ile GPIO</h2><pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n\n#define GPIO_PATH \"/sys/class/gpio/\"\n#define GPIO_PIN 18\n\nint gpio_export(int pin) {\n    char buffer[64];\n    int fd = open(GPIO_PATH \"export\", O_WRONLY);\n    if (fd == -1) return -1;\n    \n    snprintf(buffer, sizeof(buffer), \"%d\", pin);\n    write(fd, buffer, strlen(buffer));\n    close(fd);\n    return 0;\n}\n\nint gpio_set_direction(int pin, char* direction) {\n    char path[64];\n    snprintf(path, sizeof(path), GPIO_PATH \"gpio%d/direction\", pin);\n    \n    int fd = open(path, O_WRONLY);\n    if (fd == -1) return -1;\n    \n    write(fd, direction, strlen(direction));\n    close(fd);\n    return 0;\n}\n\nint gpio_write(int pin, int value) {\n    char path[64], buffer[2];\n    snprintf(path, sizeof(path), GPIO_PATH \"gpio%d/value\", pin);\n    \n    int fd = open(path, O_WRONLY);\n    if (fd == -1) return -1;\n    \n    snprintf(buffer, sizeof(buffer), \"%d\", value);\n    write(fd, buffer, 1);\n    close(fd);\n    return 0;\n}\n\nint main() {\n    gpio_export(GPIO_PIN);\n    gpio_set_direction(GPIO_PIN, \"out\");\n    \n    // LED yanıp sönme\n    for(int i = 0; i < 10; i++) {\n        gpio_write(GPIO_PIN, 1);\n        sleep(1);\n        gpio_write(GPIO_PIN, 0);\n        sleep(1);\n    }\n    \n    return 0;\n}</code></pre><h2>libgpiod Kullanımı</h2><p>Modern Linux dağıtımlarında libgpiod kütüphanesi önerilir:</p><pre><code class=\"language-bash\"># libgpiod araçlarını yükle\nsudo apt install gpiod libgpiod-dev\n\n# GPIO pinlerini listele\ngpioinfo\n\n# Pin 18'i yüksek seviyeye çek\ngpioset gpiochip0 18=1\n\n# Pin 18'den değer oku\ngpioget gpiochip0 18</code></pre><h2>Kesme (Interrupt) Yönetimi</h2><p>GPIO pinlerinde kenar tetikleme ile kesme yönetimi yapılabilir:</p><pre><code class=\"language-c\">#include &lt;poll.h&gt;\n#include &lt;fcntl.h&gt;\n\nint gpio_set_edge(int pin, char* edge) {\n    char path[64];\n    snprintf(path, sizeof(path), GPIO_PATH \"gpio%d/edge\", pin);\n    \n    int fd = open(path, O_WRONLY);\n    if (fd == -1) return -1;\n    \n    write(fd, edge, strlen(edge));\n    close(fd);\n    return 0;\n}\n\nint main() {\n    int gpio_pin = 24;\n    char gpio_value_path[64];\n    \n    gpio_export(gpio_pin);\n    gpio_set_direction(gpio_pin, \"in\");\n    gpio_set_edge(gpio_pin, \"rising\");\n    \n    snprintf(gpio_value_path, sizeof(gpio_value_path), \n             GPIO_PATH \"gpio%d/value\", gpio_pin);\n    \n    int fd = open(gpio_value_path, O_RDONLY);\n    \n    struct pollfd pfd;\n    pfd.fd = fd;\n    pfd.events = POLLPRI;\n    \n    while(1) {\n        if(poll(&pfd, 1, -1) > 0) {\n            if(pfd.revents & POLLPRI) {\n                printf(\"Kesme algılandı!\\n\");\n                lseek(fd, 0, SEEK_SET);\n                char value;\n                read(fd, &value, 1);\n            }\n        }\n    }\n    \n    close(fd);\n    return 0;\n}</code></pre><blockquote><p><strong>Önemli Not:</strong> GPIO pinlerini kullanırken elektriksel özelliklere dikkat edin. Raspberry Pi GPIO pinleri 3.3V seviyesinde çalışır ve maksimum 16mA akım çekebilir.</p></blockquote>",
      "tags": [
        "Linux",
        "GPIO",
        "Raspberry Pi",
        "C"
      ],
      "date": "2025-01-05T16:45:00Z",
      "views": 2,
      "updatedDate": "2025-05-23T21:20:35.519Z"
    },
    {
      "id": 4,
      "title": "CAN Bus Protokolü Uygulaması",
      "summary": "Otomotiv projelerinde CAN bus haberleşme protokolünün implementasyonu",
      "content": "<h1>CAN Bus Haberleşme</h1><p>Controller Area Network (CAN) protokolü, otomotiv endüstrisinde yaygın olarak kullanılan güvenilir bir haberleşme protokolüdür.</p><h2>CAN Bus Nedir?</h2><p>CAN Bus, 1980'lerde Bosch tarafından geliştirilen, yüksek güvenilirlikli ve gerçek zamanlı haberleşme sağlayan bir seri haberleşme protokolüdür. Özellikle gürültülü ortamlarda çalışan otomotiv uygulamaları için tasarlanmıştır.</p><h2>CAN Bus Özellikleri</h2><ul><li><strong>Çoklu master yapısı</strong>: Herhangi bir düğüm bus'ı başlatabilir</li><li><strong>Hata tespit ve düzeltme</strong>: CRC kontrolü ve automatic repeat request</li><li><strong>Öncelik tabanlı erişim</strong>: Düşük ID'li mesajlar önceliklidir</li><li><strong>Broadcast haberleşme</strong>: Bir mesaj tüm düğümler tarafından alınır</li><li><strong>Yüksek hız</strong>: 1 Mbps'e kadar hız desteği</li></ul><h2>CAN Frame Yapısı</h2><p>Standart CAN frame 7 bölümden oluşur:</p><ol><li><strong>SOF (Start of Frame)</strong>: 1 bit, frame başlangıcı</li><li><strong>Arbitration Field</strong>: 12 bit (11-bit ID + RTR bit)</li><li><strong>Control Field</strong>: 6 bit</li><li><strong>Data Field</strong>: 0-64 bit (0-8 byte)</li><li><strong>CRC Field</strong>: 16 bit</li><li><strong>ACK Field</strong>: 2 bit</li><li><strong>EOF (End of Frame)</strong>: 7 bit</li></ol><h2>STM32 ile CAN Implementasyonu</h2><pre><code class=\"language-c\">#include \"stm32f4xx_hal.h\"\n\nCAN_HandleTypeDef hcan1;\n\n// CAN konfigürasyonu\nvoid CAN_Config(void) {\n    CAN_FilterTypeDef sFilterConfig;\n    \n    // CAN başlatma\n    hcan1.Instance = CAN1;\n    hcan1.Init.Prescaler = 21;  // 1 Mbps için\n    hcan1.Init.Mode = CAN_MODE_NORMAL;\n    hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;\n    hcan1.Init.TimeSeg1 = CAN_BS1_6TQ;\n    hcan1.Init.TimeSeg2 = CAN_BS2_1TQ;\n    hcan1.Init.TimeTriggeredMode = DISABLE;\n    hcan1.Init.AutoBusOff = DISABLE;\n    hcan1.Init.AutoWakeUp = DISABLE;\n    hcan1.Init.AutoRetransmission = ENABLE;\n    hcan1.Init.ReceiveFifoLocked = DISABLE;\n    hcan1.Init.TransmitFifoPriority = DISABLE;\n    \n    HAL_CAN_Init(&hcan1);\n    \n    // Filtre konfigürasyonu\n    sFilterConfig.FilterBank = 0;\n    sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;\n    sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;\n    sFilterConfig.FilterIdHigh = 0x0000;\n    sFilterConfig.FilterIdLow = 0x0000;\n    sFilterConfig.FilterMaskIdHigh = 0x0000;\n    sFilterConfig.FilterMaskIdLow = 0x0000;\n    sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;\n    sFilterConfig.FilterActivation = ENABLE;\n    sFilterConfig.SlaveStartFilterBank = 14;\n    \n    HAL_CAN_ConfigFilter(&hcan1, &sFilterConfig);\n    HAL_CAN_Start(&hcan1);\n    HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);\n}\n\n// CAN mesaj gönderme\nvoid CAN_SendMessage(uint32_t id, uint8_t *data, uint8_t len) {\n    CAN_TxHeaderTypeDef TxHeader;\n    uint32_t TxMailbox;\n    \n    TxHeader.StdId = id;\n    TxHeader.RTR = CAN_RTR_DATA;\n    TxHeader.IDE = CAN_ID_STD;\n    TxHeader.DLC = len;\n    TxHeader.TransmitGlobalTime = DISABLE;\n    \n    HAL_CAN_AddTxMessage(&hcan1, &TxHeader, data, &TxMailbox);\n}\n\n// CAN mesaj alma callback\nvoid HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) {\n    CAN_RxHeaderTypeDef RxHeader;\n    uint8_t RxData[8];\n    \n    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, RxData);\n    \n    // Gelen mesajı işle\n    switch(RxHeader.StdId) {\n        case 0x123:\n            // Motor kontrol mesajı\n            ProcessMotorCommand(RxData);\n            break;\n        case 0x456:\n            // Sensör data mesajı\n            ProcessSensorData(RxData);\n            break;\n        default:\n            break;\n    }\n}</code></pre><h2>CAN Bus Hata Yönetimi</h2><p>CAN protokolü güçlü hata tespit mekanizmalarına sahiptir:</p><ul><li><strong>Bit Error</strong>: Gönderilen bit ile okunan bit farklı</li><li><strong>Stuff Error</strong>: Bit stuffing kuralına aykırılık</li><li><strong>CRC Error</strong>: CRC kontrolü başarısız</li><li><strong>Form Error</strong>: Frame formatı hatalı</li><li><strong>ACK Error</strong>: ACK alınmadı</li></ul><h2>Praktik Uygulama Örnekleri</h2><h3>Otomotiv ECU Haberleşmesi</h3><pre><code class=\"language-c\">// Motor RPM gönderme (Engine ECU)\nvoid SendEngineRPM(uint16_t rpm) {\n    uint8_t data[8] = {0};\n    data[0] = (rpm >> 8) & 0xFF;  // High byte\n    data[1] = rpm & 0xFF;         // Low byte\n    data[2] = GetEngineTemp();\n    data[3] = GetThrottlePosition();\n    \n    CAN_SendMessage(0x200, data, 4);\n}\n\n// Hız bilgisi gönderme (ABS ECU)\nvoid SendVehicleSpeed(uint16_t speed_kmh) {\n    uint8_t data[8] = {0};\n    data[0] = (speed_kmh >> 8) & 0xFF;\n    data[1] = speed_kmh & 0xFF;\n    data[2] = GetBrakeStatus();\n    \n    CAN_SendMessage(0x300, data, 3);\n}</code></pre><h2>CAN Bus Fiziksel Katman</h2><p>CAN bus fiziksel bağlantı için:</p><ul><li><strong>CAN Transceiver</strong>: MCP2551, TJA1050 gibi</li><li><strong>Sonlandırma direnci</strong>: Her iki uçta 120Ω</li><li><strong>Twisted pair kablo</strong>: CAN_H ve CAN_L hatları</li><li><strong>Common mode filtre</strong>: EMI koruması için</li></ul><blockquote><p><strong>Pratik İpucu:</strong> CAN bus ağını test ederken oscilloscope ile differential sinyalleri gözlemleyin. Sağlıklı bir CAN sinyali 2V fark ile çalışır (CAN_H: 3.5V, CAN_L: 1.5V).</p></blockquote>",
      "tags": [
        "CAN",
        "Automotive",
        "Protocol",
        "C"
      ],
      "date": "2025-01-02T11:15:00Z",
      "views": 2,
      "updatedDate": "2025-05-23T21:20:35.029Z"
    },
    {
      "id": 5,
      "title": "Low Power Design Teknikleri",
      "summary": "Pil ile çalışan gömülü sistemlerde güç tüketimi optimizasyonu",
      "content": "<h1>CAN Bus Haberleşme</h1><p>Controller Area Network (CAN) protokolü, otomotiv endüstrisinde yaygın olarak kullanılan güvenilir bir haberleşme protokolüdür.</p><h2>CAN Bus Nedir?</h2><p>CAN Bus, 1980'lerde Bosch tarafından geliştirilen, yüksek güvenilirlikli ve gerçek zamanlı haberleşme sağlayan bir seri haberleşme protokolüdür. Özellikle gürültülü ortamlarda çalışan otomotiv uygulamaları için tasarlanmıştır.</p><h2>CAN Bus Özellikleri</h2><ul><li><strong>Çoklu master yapısı</strong>: Herhangi bir düğüm bus'ı başlatabilir</li><li><strong>Hata tespit ve düzeltme</strong>: CRC kontrolü ve automatic repeat request</li><li><strong>Öncelik tabanlı erişim</strong>: Düşük ID'li mesajlar önceliklidir</li><li><strong>Broadcast haberleşme</strong>: Bir mesaj tüm düğümler tarafından alınır</li><li><strong>Yüksek hız</strong>: 1 Mbps'e kadar hız desteği</li></ul><h2>CAN Frame Yapısı</h2><p>Standart CAN frame 7 bölümden oluşur:</p><ol><li><strong>SOF (Start of Frame)</strong>: 1 bit, frame başlangıcı</li><li><strong>Arbitration Field</strong>: 12 bit (11-bit ID + RTR bit)</li><li><strong>Control Field</strong>: 6 bit</li><li><strong>Data Field</strong>: 0-64 bit (0-8 byte)</li><li><strong>CRC Field</strong>: 16 bit</li><li><strong>ACK Field</strong>: 2 bit</li><li><strong>EOF (End of Frame)</strong>: 7 bit</li></ol><h2>STM32 ile CAN Implementasyonu</h2><pre><code class=\"language-c\">#include \"stm32f4xx_hal.h\"\n\nCAN_HandleTypeDef hcan1;\n\n// CAN konfigürasyonu\nvoid CAN_Config(void) {\n    CAN_FilterTypeDef sFilterConfig;\n    \n    // CAN başlatma\n    hcan1.Instance = CAN1;\n    hcan1.Init.Prescaler = 21;  // 1 Mbps için\n    hcan1.Init.Mode = CAN_MODE_NORMAL;\n    hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;\n    hcan1.Init.TimeSeg1 = CAN_BS1_6TQ;\n    hcan1.Init.TimeSeg2 = CAN_BS2_1TQ;\n    hcan1.Init.TimeTriggeredMode = DISABLE;\n    hcan1.Init.AutoBusOff = DISABLE;\n    hcan1.Init.AutoWakeUp = DISABLE;\n    hcan1.Init.AutoRetransmission = ENABLE;\n    hcan1.Init.ReceiveFifoLocked = DISABLE;\n    hcan1.Init.TransmitFifoPriority = DISABLE;\n    \n    HAL_CAN_Init(&hcan1);\n    \n    // Filtre konfigürasyonu\n    sFilterConfig.FilterBank = 0;\n    sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;\n    sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;\n    sFilterConfig.FilterIdHigh = 0x0000;\n    sFilterConfig.FilterIdLow = 0x0000;\n    sFilterConfig.FilterMaskIdHigh = 0x0000;\n    sFilterConfig.FilterMaskIdLow = 0x0000;\n    sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;\n    sFilterConfig.FilterActivation = ENABLE;\n    sFilterConfig.SlaveStartFilterBank = 14;\n    \n    HAL_CAN_ConfigFilter(&hcan1, &sFilterConfig);\n    HAL_CAN_Start(&hcan1);\n    HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING);\n}\n\n// CAN mesaj gönderme\nvoid CAN_SendMessage(uint32_t id, uint8_t *data, uint8_t len) {\n    CAN_TxHeaderTypeDef TxHeader;\n    uint32_t TxMailbox;\n    \n    TxHeader.StdId = id;\n    TxHeader.RTR = CAN_RTR_DATA;\n    TxHeader.IDE = CAN_ID_STD;\n    TxHeader.DLC = len;\n    TxHeader.TransmitGlobalTime = DISABLE;\n    \n    HAL_CAN_AddTxMessage(&hcan1, &TxHeader, data, &TxMailbox);\n}\n\n// CAN mesaj alma callback\nvoid HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) {\n    CAN_RxHeaderTypeDef RxHeader;\n    uint8_t RxData[8];\n    \n    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, RxData);\n    \n    // Gelen mesajı işle\n    switch(RxHeader.StdId) {\n        case 0x123:\n            // Motor kontrol mesajı\n            ProcessMotorCommand(RxData);\n            break;\n        case 0x456:\n            // Sensör data mesajı\n            ProcessSensorData(RxData);\n            break;\n        default:\n            break;\n    }\n}</code></pre><h2>CAN Bus Hata Yönetimi</h2><p>CAN protokolü güçlü hata tespit mekanizmalarına sahiptir:</p><ul><li><strong>Bit Error</strong>: Gönderilen bit ile okunan bit farklı</li><li><strong>Stuff Error</strong>: Bit stuffing kuralına aykırılık</li><li><strong>CRC Error</strong>: CRC kontrolü başarısız</li><li><strong>Form Error</strong>: Frame formatı hatalı</li><li><strong>ACK Error</strong>: ACK alınmadı</li></ul><h2>Praktik Uygulama Örnekleri</h2><h3>Otomotiv ECU Haberleşmesi</h3><pre><code class=\"language-c\">// Motor RPM gönderme (Engine ECU)\nvoid SendEngineRPM(uint16_t rpm) {\n    uint8_t data[8] = {0};\n    data[0] = (rpm >> 8) & 0xFF;  // High byte\n    data[1] = rpm & 0xFF;         // Low byte\n    data[2] = GetEngineTemp();\n    data[3] = GetThrottlePosition();\n    \n    CAN_SendMessage(0x200, data, 4);\n}\n\n// Hız bilgisi gönderme (ABS ECU)\nvoid SendVehicleSpeed(uint16_t speed_kmh) {\n    uint8_t data[8] = {0};\n    data[0] = (speed_kmh >> 8) & 0xFF;\n    data[1] = speed_kmh & 0xFF;\n    data[2] = GetBrakeStatus();\n    \n    CAN_SendMessage(0x300, data, 3);\n}</code></pre><h2>CAN Bus Fiziksel Katman</h2><p>CAN bus fiziksel bağlantı için:</p><ul><li><strong>CAN Transceiver</strong>: MCP2551, TJA1050 gibi</li><li><strong>Sonlandırma direnci</strong>: Her iki uçta 120Ω</li><li><strong>Twisted pair kablo</strong>: CAN_H ve CAN_L hatları</li><li><strong>Common mode filtre</strong>: EMI koruması için</li></ul><blockquote><p><strong>Pratik İpucu:</strong> CAN bus ağını test ederken oscilloscope ile differential sinyalleri gözlemleyin. Sağlıklı bir CAN sinyali 2V fark ile çalışır (CAN_H: 3.5V, CAN_L: 1.5V).</p></blockquote>",
      "tags": [
        "CAN",
        "Automotive",
        "Protocol",
        "C"
      ],
      "date": "2025-01-02T11:15:00Z",
      "views": 2,
      "updatedDate": "2025-05-23T21:20:35.029Z"
    }
  ]
}